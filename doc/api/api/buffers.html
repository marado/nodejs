<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>buffers - Node.js v0.5.6 Manual &amp; Documentation</title>
  <link type="image/x-icon" rel="icon" href="/favicon.ico" />
  <link type="image/x-icon" rel="shortcut icon" href="/favicon.ico" />
  <link rel="stylesheet" href="assets/style.css" type="text/css" media="all" />
  <link rel="stylesheet" href="assets/sh.css" type="text/css" media="all"/>
</head>
<body>
  <div id="container">
    <header>
      <h1>Node.js v0.5.6 Manual &amp; Documentation</h1>
      <div id="gtoc">
        <p><a href="index.html">Index</a> | <a href="all.html">View on single page</a></p>
      </div>
      <hr />
    </header>
    <div id="toc"><h2>Table Of Contents</h2><ul><li><a href="#buffers_">Buffers</a><ul><li><a href="#new_Buffer_">new Buffer(size)</a></li><li><a href="#new_Buffer_">new Buffer(array)</a></li><li><a href="#new_Buffer_">new Buffer(str, encoding='utf8')</a></li><li><a href="#buffer.write_">buffer.write(string, offset=0, length=buffer.length-offset, encoding='utf8')</a></li><li><a href="#buffer.toString_">buffer.toString(encoding, start=0, end=buffer.length)</a></li><li><a href="#buffer_index_">buffer[index]</a></li><li><a href="#buffer.isBuffer_">Buffer.isBuffer(obj)</a></li><li><a href="#buffer.byteLength_">Buffer.byteLength(string, encoding='utf8')</a></li><li><a href="#buffer.length_">buffer.length</a></li><li><a href="#buffer.copy_">buffer.copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)</a></li><li><a href="#buffer.slice_">buffer.slice(start, end=buffer.length)</a></li><li><a href="#buffer.readUInt8_">buffer.readUInt8(offset, noAssert=false)</a></li><li><a href="#buffer.readUInt16LE_">buffer.readUInt16LE(offset, noAssert=false)</a></li><li><a href="#buffer.readUInt16BE_">buffer.readUInt16BE(offset, noAssert=false)</a></li><li><a href="#buffer.readUInt32LE_">buffer.readUInt32LE(offset, noAssert=false)</a></li><li><a href="#buffer.readUInt32BE_">buffer.readUInt32BE(offset, noAssert=false)</a></li><li><a href="#buffer.readInt8_">buffer.readInt8(offset, noAssert=false)</a></li><li><a href="#buffer.readInt16LE_">buffer.readInt16LE(offset, noAssert=false)</a></li><li><a href="#buffer.readInt16BE_">buffer.readInt16BE(offset, noAssert=false)</a></li><li><a href="#buffer.readInt32LE_">buffer.readInt32LE(offset, noAssert=false)</a></li><li><a href="#buffer.readInt32BE_">buffer.readInt32BE(offset, noAssert=false)</a></li><li><a href="#buffer.readFloatLE_">buffer.readFloatLE(offset, noAssert=false)</a></li><li><a href="#buffer.readFloatBE_">buffer.readFloatBE(offset, noAssert=false)</a></li><li><a href="#buffer.readDoubleLE_">buffer.readDoubleLE(offset, noAssert=false)</a></li><li><a href="#buffer.readDoubleBE_">buffer.readDoubleBE(offset, noAssert=false)</a></li><li><a href="#buffer.writeUInt8_">buffer.writeUInt8(value, offset, noAssert=false)</a></li><li><a href="#buffer.writeUInt16LE_">buffer.writeUInt16LE(value, offset, noAssert=false)</a></li><li><a href="#buffer.writeUInt16BE_">buffer.writeUInt16BE(value, offset, noAssert=false)</a></li><li><a href="#buffer.writeUInt32LE_">buffer.writeUInt32LE(value, offset, noAssert=false)</a></li><li><a href="#buffer.writeUInt32BE_">buffer.writeUInt32BE(value, offset, noAssert=false)</a></li><li><a href="#buffer.writeInt8_">buffer.writeInt8(value, offset, noAssert=false)</a></li><li><a href="#buffer.writeInt16LE_">buffer.writeInt16LE(value, offset, noAssert=false)</a></li><li><a href="#buffer.writeInt16BE_">buffer.writeInt16BE(value, offset, noAssert=false)</a></li><li><a href="#buffer.writeInt32LE_">buffer.writeInt32LE(value, offset, noAssert=false)</a></li><li><a href="#buffer.writeInt32BE_">buffer.writeInt32BE(value, offset, noAssert=false)</a></li><li><a href="#buffer.writeFloatLE_">buffer.writeFloatLE(value, offset, noAssert=false)</a></li><li><a href="#buffer.writeFloatBE_">buffer.writeFloatBE(value, offset, noAssert=false)</a></li><li><a href="#buffer.writeDoubleLE_">buffer.writeDoubleLE(value, offset, noAssert=false)</a></li><li><a href="#buffer.writeDoubleBE_">buffer.writeDoubleBE(value, offset, noAssert=false)</a></li><li><a href="#buffer.fill_">buffer.fill(value, offset=0, length=-1)</a></li><li><a href="#iNSPECT_MAX_BYTES_">INSPECT_MAX_BYTES</a></li></ul></li></ul><hr /></div>
<h2 id="buffers">Buffers</h2>

<p>Pure Javascript is Unicode friendly but not nice to binary data.  When
dealing with TCP streams or the file system, it's necessary to handle octet
streams. Node has several strategies for manipulating, creating, and
consuming octet streams.</p>

<p>Raw data is stored in instances of the <code>Buffer</code> class. A <code>Buffer</code> is similar
to an array of integers but corresponds to a raw memory allocation outside
the V8 heap. A <code>Buffer</code> cannot be resized.</p>

<p>The <code>Buffer</code> object is global.</p>

<p>Converting between Buffers and JavaScript string objects requires an explicit encoding
method.  Here are the different string encodings;</p>

<ul><li><p><code>'ascii'</code> - for 7 bit ASCII data only.  This encoding method is very fast, and will
strip the high bit if set.
Note that this encoding converts a null character (<code>'\0'</code> or <code>'\u0000'</code>) into
<code>0x20</code> (character code of a space). If you want to convert a null character
into <code>0x00</code>, you should use <code>'utf8'</code>.</p></li><li><p><code>'utf8'</code> - Multi byte encoded Unicode characters.  Many web pages and other document formats use UTF-8.</p></li><li><p><code>'ucs2'</code> - 2-bytes, little endian encoded Unicode characters. It can encode
only BMP(Basic Multilingual Plane, U+0000 - U+FFFF).</p></li><li><p><code>'base64'</code> - Base64 string encoding.</p></li><li><p><code>'binary'</code> - A way of encoding raw binary data into strings by using only
the first 8 bits of each character. This encoding method is deprecated and
should be avoided in favor of <code>Buffer</code> objects where possible. This encoding
will be removed in future versions of Node.</p></li><li><p><code>'hex'</code> - Encode each byte as two hexidecimal characters.</p></li></ul>

<h3 id="new_Buffer">new Buffer(size)</h3>

<p>Allocates a new buffer of <code>size</code> octets.</p>

<h3 id="new_Buffer">new Buffer(array)</h3>

<p>Allocates a new buffer using an <code>array</code> of octets.</p>

<h3 id="new_Buffer">new Buffer(str, encoding='utf8')</h3>

<p>Allocates a new buffer containing the given <code>str</code>.</p>

<h3 id="buffer.write">buffer.write(string, offset=0, length=buffer.length-offset, encoding='utf8')</h3>

<p>Writes <code>string</code> to the buffer at <code>offset</code> using the given encoding. <code>length</code> is
the number of bytes to write. Returns number of octets written. If <code>buffer</code> did
not contain enough space to fit the entire string, it will write a partial
amount of the string. The method will not write partial characters.</p>

<p>Example: write a utf8 string into a buffer, then print it</p>

<pre><code>buf = new Buffer(256);</code></pre>

<p>
    len = buf.write('\u00bd + \u00bc = \u00be', 0);
    console.log(len + " bytes: " + buf.toString('utf8', 0, len));</p>

<p>The number of characters written (which may be different than the number of
bytes written) is set in <code>Buffer._charsWritten</code> and will be overwritten the
next time <code>buf.write()</code> is called.</p>

<h3 id="buffer.toString">buffer.toString(encoding, start=0, end=buffer.length)</h3>

<p>Decodes and returns a string from buffer data encoded with <code>encoding</code>
beginning at <code>start</code> and ending at <code>end</code>.</p>

<p>See <code>buffer.write()</code> example, above.</p>

<h3 id="buffer_index_">buffer[index]</h3>

<p>Get and set the octet at <code>index</code>. The values refer to individual bytes,
so the legal range is between <code>0x00</code> and <code>0xFF</code> hex or <code>0</code> and <code>255</code>.</p>

<p>Example: copy an ASCII string into a buffer, one byte at a time:</p>

<pre><code>str = "node.js";</code></pre>

<p>
    buf = new Buffer(str.length);</p>

<pre><code>for (var i = 0; i &lt; str.length ; i++) {</code></pre>

<p>
      buf[i] = str.charCodeAt(i);
    }</p>

<pre><code>console.log(buf);</code></pre>

<p></p>

<pre><code>// node.js</code></pre>

<p></p>

<h3 id="buffer.isBuffer">Buffer.isBuffer(obj)</h3>

<p>Tests if <code>obj</code> is a <code>Buffer</code>.</p>

<h3 id="buffer.byteLength">Buffer.byteLength(string, encoding='utf8')</h3>

<p>Gives the actual byte length of a string.  This is not the same as
<code>String.prototype.length</code> since that returns the number of <em>characters</em> in a
string.</p>

<p>Example:</p>

<pre><code>str = '\u00bd + \u00bc = \u00be';</code></pre>

<p></p>

<pre><code>console.log(str + ": " + str.length + " characters, " +</code></pre>

<p>
      Buffer.byteLength(str, 'utf8') + " bytes");</p>

<pre><code>// ½ + ¼ = ¾: 9 characters, 12 bytes</code></pre>

<p></p>

<h3 id="buffer.length">buffer.length</h3>

<p>The size of the buffer in bytes.  Note that this is not necessarily the size
of the contents. <code>length</code> refers to the amount of memory allocated for the
buffer object.  It does not change when the contents of the buffer are changed.</p>

<pre><code>buf = new Buffer(1234);</code></pre>

<p></p>

<pre><code>console.log(buf.length);</code></pre>

<p>
    buf.write("some string", "ascii", 0);
    console.log(buf.length);</p>

<pre><code>// 1234</code></pre>

<p>
    // 1234</p>

<h3 id="buffer.copy">buffer.copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)</h3>

<p>Does copy between buffers. The source and target regions can be overlapped.</p>

<p>Example: build two Buffers, then copy <code>buf1</code> from byte 16 through byte 19
into <code>buf2</code>, starting at the 8th byte in <code>buf2</code>.</p>

<pre><code>buf1 = new Buffer(26);</code></pre>

<p>
    buf2 = new Buffer(26);</p>

<pre><code>for (var i = 0 ; i &lt; 26 ; i++) {</code></pre>

<p>
      buf1[i] = i + 97; // 97 is ASCII a
      buf2[i] = 33; // ASCII !
    }</p>

<pre><code>buf1.copy(buf2, 8, 16, 20);</code></pre>

<p>
    console.log(buf2.toString('ascii', 0, 25));</p>

<pre><code>// !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>

<p></p>

<h3 id="buffer.slice">buffer.slice(start, end=buffer.length)</h3>

<p>Returns a new buffer which references the
same memory as the old, but offset and cropped by the <code>start</code> and <code>end</code>
indexes.</p>

<p><strong>Modifying the new buffer slice will modify memory in the original buffer!</strong></p>

<p>Example: build a Buffer with the ASCII alphabet, take a slice, then modify one
byte from the original Buffer.</p>

<pre><code>var buf1 = new Buffer(26);</code></pre>

<p></p>

<pre><code>for (var i = 0 ; i &lt; 26 ; i++) {</code></pre>

<p>
      buf1[i] = i + 97; // 97 is ASCII a
    }</p>

<pre><code>var buf2 = buf1.slice(0, 3);</code></pre>

<p>
    console.log(buf2.toString('ascii', 0, buf2.length));
    buf1[0] = 33;
    console.log(buf2.toString('ascii', 0, buf2.length));</p>

<pre><code>// abc</code></pre>

<p>
    // !bc</p>

<h3 id="buffer.readUInt8">buffer.readUInt8(offset, noAssert=false)</h3>

<p>Reads an unsigned 8 bit integer from the buffer at the specified offset.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(4);</code></pre>

<p></p>

<pre><code>buf[0] = 0x3;</code></pre>

<p>
    buf[1] = 0x4;
    buf[2] = 0x23;
    buf[3] = 0x42;</p>

<pre><code>for (ii = 0; ii &lt; buf.length; ii++) {</code></pre>

<p>
      console.log(buf.readUInt8(ii);
    }</p>

<pre><code>// 0x3</code></pre>

<p>
    // 0x4
    // 0x23
    // 0x42</p>

<h3 id="buffer.readUInt16LE">buffer.readUInt16LE(offset, noAssert=false)</h3>

<h3 id="buffer.readUInt16BE">buffer.readUInt16BE(offset, noAssert=false)</h3>

<p>Reads an unsigned 16 bit integer from the buffer at the specified offset with
specified endian format.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(4);</code></pre>

<p></p>

<pre><code>buf[0] = 0x3;</code></pre>

<p>
    buf[1] = 0x4;
    buf[2] = 0x23;
    buf[3] = 0x42;</p>

<pre><code>console.log(buf.readUInt16BE(0));</code></pre>

<p>
    console.log(buf.readUInt16LE(0));
    console.log(buf.readUInt16BE(1));
    console.log(buf.readUInt16LE(1));
    console.log(buf.readUInt16BE(2));
    console.log(buf.readUInt16LE(2));</p>

<pre><code>// 0x0304</code></pre>

<p>
    // 0x0403
    // 0x0423
    // 0x2304
    // 0x2342
    // 0x4223</p>

<h3 id="buffer.readUInt32LE">buffer.readUInt32LE(offset, noAssert=false)</h3>

<h3 id="buffer.readUInt32BE">buffer.readUInt32BE(offset, noAssert=false)</h3>

<p>Reads an unsigned 32 bit integer from the buffer at the specified offset with
specified endian format.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(4);</code></pre>

<p></p>

<pre><code>buf[0] = 0x3;</code></pre>

<p>
    buf[1] = 0x4;
    buf[2] = 0x23;
    buf[3] = 0x42;</p>

<pre><code>console.log(buf.readUInt32BE(0));</code></pre>

<p>
    console.log(buf.readUInt32LE(0));</p>

<pre><code>// 0x03042342</code></pre>

<p>
    // 0x42230403</p>

<h3 id="buffer.readInt8">buffer.readInt8(offset, noAssert=false)</h3>

<p>Reads a signed 8 bit integer from the buffer at the specified offset.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer.</p>

<p>Works as <code>buffer.readUInt8</code>, except buffer contents are treated as two's
complement signed values.</p>

<h3 id="buffer.readInt16LE">buffer.readInt16LE(offset, noAssert=false)</h3>

<h3 id="buffer.readInt16BE">buffer.readInt16BE(offset, noAssert=false)</h3>

<p>Reads a signed 16 bit integer from the buffer at the specified offset with
specified endian format.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer.</p>

<p>Works as <code>buffer.readUInt16*</code>, except buffer contents are treated as two's
complement signed values.</p>

<h3 id="buffer.readInt32LE">buffer.readInt32LE(offset, noAssert=false)</h3>

<h3 id="buffer.readInt32BE">buffer.readInt32BE(offset, noAssert=false)</h3>

<p>Reads a signed 32 bit integer from the buffer at the specified offset with
specified endian format.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer.</p>

<p>Works as <code>buffer.readUInt32*</code>, except buffer contents are treated as two's
complement signed values.</p>

<h3 id="buffer.readFloatLE">buffer.readFloatLE(offset, noAssert=false)</h3>

<h3 id="buffer.readFloatBE">buffer.readFloatBE(offset, noAssert=false)</h3>

<p>Reads a 32 bit float from the buffer at the specified offset with specified
endian format.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(4);</code></pre>

<p></p>

<pre><code>buf[0] = 0x00;</code></pre>

<p>
    buf[1] = 0x00;
    buf[2] = 0x80;
    buf[3] = 0x3f;</p>

<pre><code>console.log(buf.readFloatLE(0));</code></pre>

<p></p>

<pre><code>// 0x01</code></pre>

<p></p>

<h3 id="buffer.readDoubleLE">buffer.readDoubleLE(offset, noAssert=false)</h3>

<h3 id="buffer.readDoubleBE">buffer.readDoubleBE(offset, noAssert=false)</h3>

<p>Reads a 64 bit double from the buffer at the specified offset with specified
endian format.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(8);</code></pre>

<p></p>

<pre><code>buf[0] = 0x55;</code></pre>

<p>
    buf[1] = 0x55;
    buf[2] = 0x55;
    buf[3] = 0x55;
    buf[4] = 0x55;
    buf[5] = 0x55;
    buf[6] = 0xd5;
    buf[7] = 0x3f;</p>

<pre><code>console.log(buf.readDoubleLE(0));</code></pre>

<p></p>

<pre><code>// 0.3333333333333333</code></pre>

<p></p>

<h3 id="buffer.writeUInt8">buffer.writeUInt8(value, offset, noAssert=false)</h3>

<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a
valid unsigned 8 bit integer.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(4);</code></pre>

<p>
    buf.writeUInt8(0x3, 0);
    buf.writeUInt8(0x4, 1);
    buf.writeUInt8(0x23, 2);
    buf.writeUInt8(0x42, 3);</p>

<pre><code>console.log(buf);</code></pre>

<p></p>

<pre><code>// &lt;Buffer 03 04 23 42&gt;</code></pre>

<p></p>

<h3 id="buffer.writeUInt16LE">buffer.writeUInt16LE(value, offset, noAssert=false)</h3>

<h3 id="buffer.writeUInt16BE">buffer.writeUInt16BE(value, offset, noAssert=false)</h3>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid unsigned 16 bit integer.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(4);</code></pre>

<p>
    buf.writeUInt16BE(0xdead, 0);
    buf.writeUInt16BE(0xbeef, 2);</p>

<pre><code>console.log(buf);</code></pre>

<p></p>

<pre><code>buf.writeUInt16LE(0xdead, 0);</code></pre>

<p>
    buf.writeUInt16LE(0xbeef, 2);</p>

<pre><code>console.log(buf);</code></pre>

<p></p>

<pre><code>// &lt;Buffer de ad be ef&gt;</code></pre>

<p>
    // &lt;Buffer ad de ef be&gt;</p>

<h3 id="buffer.writeUInt32LE">buffer.writeUInt32LE(value, offset, noAssert=false)</h3>

<h3 id="buffer.writeUInt32BE">buffer.writeUInt32BE(value, offset, noAssert=false)</h3>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid unsigned 32 bit integer.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(4);</code></pre>

<p>
    buf.writeUInt32BE(0xfeedface, 0);</p>

<pre><code>console.log(buf);</code></pre>

<p></p>

<pre><code>buf.writeUInt32LE(0xfeedface, 0);</code></pre>

<p></p>

<pre><code>console.log(buf);</code></pre>

<p></p>

<pre><code>// &lt;Buffer fe ed fa ce&gt;</code></pre>

<p>
    // &lt;Buffer ce fa ed fe&gt;</p>

<h3 id="buffer.writeInt8">buffer.writeInt8(value, offset, noAssert=false)</h3>

<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a
valid signed 8 bit integer.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>

<p>Works as <code>buffer.writeUInt8</code>, except value is written out as a two's complement
signed integer into <code>buffer</code>.</p>

<h3 id="buffer.writeInt16LE">buffer.writeInt16LE(value, offset, noAssert=false)</h3>

<h3 id="buffer.writeInt16BE">buffer.writeInt16BE(value, offset, noAssert=false)</h3>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid signed 16 bit integer.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>

<p>Works as <code>buffer.writeUInt16*</code>, except value is written out as a two's
complement signed integer into <code>buffer</code>.</p>

<h3 id="buffer.writeInt32LE">buffer.writeInt32LE(value, offset, noAssert=false)</h3>

<h3 id="buffer.writeInt32BE">buffer.writeInt32BE(value, offset, noAssert=false)</h3>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid signed 32 bit integer.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>

<p>Works as <code>buffer.writeUInt32*</code>, except value is written out as a two's
complement signed integer into <code>buffer</code>.</p>

<h3 id="buffer.writeFloatLE">buffer.writeFloatLE(value, offset, noAssert=false)</h3>

<h3 id="buffer.writeFloatBE">buffer.writeFloatBE(value, offset, noAssert=false)</h3>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid 32 bit float.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(4);</code></pre>

<p>
    buf.writeFloatBE(0xcafebabe, 0);</p>

<pre><code>console.log(buf);</code></pre>

<p></p>

<pre><code>buf.writeFloatLE(0xcafebabe, 0);</code></pre>

<p></p>

<pre><code>console.log(buf);</code></pre>

<p></p>

<pre><code>// &lt;Buffer 4f 4a fe bb&gt;</code></pre>

<p>
    // &lt;Buffer bb fe 4a 4f&gt;</p>

<h3 id="buffer.writeDoubleLE">buffer.writeDoubleLE(value, offset, noAssert=false)</h3>

<h3 id="buffer.writeDoubleBE">buffer.writeDoubleBE(value, offset, noAssert=false)</h3>

<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid 64 bit double.</p>

<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>

<p>Example:</p>

<pre><code>var buf = new Buffer(8);</code></pre>

<p>
    buf.writeDoubleBE(0xdeadbeefcafebabe, 0);</p>

<pre><code>console.log(buf);</code></pre>

<p></p>

<pre><code>buf.writeDoubleLE(0xdeadbeefcafebabe, 0);</code></pre>

<p></p>

<pre><code>console.log(buf);</code></pre>

<p></p>

<pre><code>// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;</code></pre>

<p>
    // &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</p>

<h3 id="buffer.fill">buffer.fill(value, offset=0, length=-1)</h3>

<p>Fills the buffer with the specified value. If the offset and length are not
given it will fill the entire buffer.</p>

<pre><code>var b = new Buffer(50);</code></pre>

<p>
    b.fill("h");</p>

<h3 id="iNSPECT_MAX_BYTES">INSPECT_MAX_BYTES</h3>

<p>How many bytes will be returned when <code>buffer.inspect()</code> is called. This can
be overriden by user modules.</p>
  </div>
  <script type="text/javascript" src="assets/sh_main.js"></script>
  <script type="text/javascript" src="assets/sh_javascript.min.js"></script>
  <script type="text/javascript">highlight(undefined, undefined, 'pre');</script>
</body>
</html>
