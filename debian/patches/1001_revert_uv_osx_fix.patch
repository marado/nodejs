Author: Ben Noordhuis <info@bnoordhuis.nl>
Last-Update: 2013-05-29
Origin: https://github.com/joyent/libuv/commit/c53fe815442
Subject: [PATCH] unix: implicitly signal write errors to libuv user
 Actually, REVERT that patch.
Acked-By: Jérémy Lal <kapouer@melix.org>
--- a/deps/uv/src/unix/stream.c
+++ b/deps/uv/src/unix/stream.c
@@ -60,7 +60,6 @@
 static void uv__write(uv_stream_t* stream);
 static void uv__read(uv_stream_t* stream);
 static void uv__stream_io(uv_loop_t* loop, uv__io_t* w, unsigned int events);
-static size_t uv__write_req_size(uv_write_t* req);
 
 
 /* Used by the accept() EMFILE party trick. */
@@ -400,7 +399,6 @@
 
     if (req->bufs != req->bufsml)
       free(req->bufs);
-    req->bufs = NULL;
 
     if (req->cb) {
       uv__set_artificial_error(req->handle->loop, UV_ECANCELED);
@@ -415,13 +413,6 @@
     req = ngx_queue_data(q, uv_write_t, queue);
     uv__req_unregister(stream->loop, req);
 
-    if (req->bufs != NULL) {
-      stream->write_queue_size -= uv__write_req_size(req);
-      if (req->bufs != req->bufsml)
-        free(req->bufs);
-      req->bufs = NULL;
-    }
-
     if (req->cb) {
       uv__set_sys_error(stream->loop, req->error);
       req->cb(req, req->error ? -1 : 0);
@@ -661,7 +652,6 @@
 static size_t uv__write_req_size(uv_write_t* req) {
   size_t size;
 
-  assert(req->bufs != NULL);
   size = uv__buf_count(req->bufs + req->write_index,
                        req->bufcnt - req->write_index);
   assert(req->handle->write_queue_size >= size);
@@ -675,18 +665,10 @@
 
   /* Pop the req off tcp->write_queue. */
   ngx_queue_remove(&req->queue);
-
-  /* Only free when there was no error. On error, we touch up write_queue_size
-   * right before making the callback. The reason we don't do that right away
-   * is that a write_queue_size > 0 is our only way to signal to the user that
-   * he should stop writing - which he should if we got an error. Something to
-   * revisit in future revisions of the libuv API.
-   */
-  if (req->error == 0) {
-    if (req->bufs != req->bufsml)
-      free(req->bufs);
-    req->bufs = NULL;
+  if (req->bufs != req->bufsml) {
+    free(req->bufs);
   }
+  req->bufs = NULL;
 
   /* Add it to the write_completed_queue where it will have its
    * callback called in the near future.
@@ -796,6 +778,7 @@
     if (errno != EAGAIN && errno != EWOULDBLOCK) {
       /* Error */
       req->error = errno;
+      stream->write_queue_size -= uv__write_req_size(req);
       uv__write_req_finish(req);
       return;
     } else if (stream->flags & UV_STREAM_BLOCKING) {
@@ -872,13 +855,6 @@
     ngx_queue_remove(q);
     uv__req_unregister(stream->loop, req);
 
-    if (req->bufs != NULL) {
-      stream->write_queue_size -= uv__write_req_size(req);
-      if (req->bufs != req->bufsml)
-        free(req->bufs);
-      req->bufs = NULL;
-    }
-
     /* NOTE: call callback AFTER freeing the request data. */
     if (req->cb) {
       uv__set_sys_error(stream->loop, req->error);
